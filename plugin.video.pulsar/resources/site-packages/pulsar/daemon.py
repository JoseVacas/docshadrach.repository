import sys
import subprocess
import os
import signal
import stat
import xbmc
import xbmcaddon
import urllib2
import threading
import time
from pulsar.config import PULSARD_HOST
from pulsar.platform import PLATFORM
from pulsar.util import notify


SW_HIDE = 0
STARTF_USESHOWWINDOW = 1


def ensure_exec_perms(file_):
    st = os.stat(file_)
    os.chmod(file_, st.st_mode | stat.S_IEXEC)
    return file_


def android_get_current_appid():
    uid = os.getuid()
    with open("/proc/%d/cmdline", uid) as fp:
        return fp.read().rstrip()


def get_pulsar_binary():
    binary = "pulsar" + (PLATFORM["os"] == "windows" and ".exe" or "")

    platform = PLATFORM.copy()
    if platform["os"] == "darwin": # 64 bits anyway on Darwin
        platform["arch"] = "x64"
    elif platform["os"] == "windows": # 32 bits anyway on Windows
        platform["arch"] = "x86"

    binary_dir = os.path.join(os.path.dirname(__file__), "..", "..", "bin", "%(os)s_%(arch)s" % platform)
    binary_path = os.path.join(binary_dir, binary)

    # On Android, we need to copy pulsard to ext4, since the sdcard is noexec
    if platform["os"] == "android":
        app_id = android_get_current_appid()
        xbmc_data_path = os.path.join("/data", "data", app_id)
        if os.path.exists(xbmc_data_path) and uid == os.stat(xbmc_data_path).st_uid:
            android_binary_dir = os.path.join(xbmc_data_path, "files", ADDON.getAddonInfo("id"))

        if not os.path.exists(android_binary_dir):
            os.makedirs(android_binary_dir)
        android_binary_path = os.path.join(android_binary_dir, binary)
        # Testing for size to see if update is needed. This is a poor test indeed, but it's sufficient.
        if not os.path.exists(android_binary_path) or os.path.getsize(android_binary_path) != os.path.getsize(binary_path):
            import shutil
            shutil.copy2(binary_path, android_binary_path)
        binary_path = android_binary_path
        binary_dir = android_binary_dir

    return binary_dir, ensure_exec_perms(binary_path)


def start_pulsard(**kwargs):
    pulsar_dir, pulsar_binary = get_pulsar_binary()
    args = [pulsar_binary]
    kwargs["cwd"] = pulsar_dir
    if PLATFORM["os"] == "windows":
        si = subprocess.STARTUPINFO()
        si.dwFlags = STARTF_USESHOWWINDOW
        si.wShowWindow = SW_HIDE
        kwargs["startupinfo"] = si
    return subprocess.Popen(args, **kwargs)


def wait_for_abortRequested(proc):
    while not xbmc.abortRequested:
        time.sleep(1)
    xbmc.log("pulsard: exiting pulsard daemon")
    proc.terminate()
    xbmc.log("pulsard: pulsard daemon exited")


def pulsard_thread():
    while not xbmc.abortRequested:
        xbmc.log("pulsard: starting pulsard")
        proc = start_pulsard(stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        threading.Thread(target=wait_for_abortRequested, args=[proc]).start()
        while proc.poll() is None:
            xbmc.log(proc.stdout.readline())
        if proc.returncode == 0 or xbmc.abortRequested:
            break
        notify("Pulsar has crashed, restarting...", time=1000)
